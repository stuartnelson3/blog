{"title":"AngularJS Isolate Scope Primer","body":"\u003cp\u003eOne of the most confusing things when starting out with Angular is isolate\nscope. What do those funny symbols mean? Which attribute name maps to what in\nmy directive element? Here\u0026rsquo;s a short list of examples to (hopefully)\nstraighten it out:\u003c/p\u003e\n\n\u003ch2\u003ebaz: \u0026lsquo;=\u0026rsquo;\u003c/h2\u003e\n\n\u003cp\u003eThe \u003ccode\u003e=\u003c/code\u003e is probably going to be your most frequently used directive binding. It\u0026rsquo;s used for two way binding between the parent scope and the isolate scope:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"javascript\"\u003eangular.module('App.controllers').controller('ParentCtrl', function($scope) {\n  $scope.foo = \u0026quot;bar\u0026quot;;\n});\n\nangular.module('App.directives').directive('isolateDirective', function() {\n  return {\n    scope: {\n      baz: '='\n    },\n    restrict: \u0026quot;E\u0026quot;\n  };\n});\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eA variable \u003ccode\u003efoo\u003c/code\u003e exists in the parent scope, and we are going to bind it into \u003ccode\u003eisolateDirective\u003c/code\u003e.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"html\"\u003e\u0026lt;div ng-controller=\u0026quot;ParentCtrl\u0026quot;\u0026gt;\n  \u0026lt;isolate-directive baz=\u0026quot;foo\u0026quot;\u0026gt;\u0026lt;/isolate-directive\u0026gt;\n\u0026lt;/div\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThere, simple as that. Within our \u003ccode\u003ediv\u003c/code\u003e we have access to everything attached to \u003ccode\u003e$scope\u003c/code\u003e on \u003ccode\u003eParentCtrl\u003c/code\u003e, which includes \u003ccode\u003efoo\u003c/code\u003e. We declare our directive as an element (notice the \u003ccode\u003erestrict: \u0026quot;E\u0026quot;\u003c/code\u003e in the directive), and set \u003ccode\u003ebaz\u003c/code\u003e (in our isolate scope) equal to \u003ccode\u003efoo\u003c/code\u003e (from our parent scope). \u003ccode\u003escope.baz\u003c/code\u003e is now set in our directive, and it is equal to \u003ccode\u003efoo\u003c/code\u003e from \u003ccode\u003eParentCtrl\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eWhat\u0026rsquo;s more, since we bound \u003ccode\u003efoo\u003c/code\u003e to \u003ccode\u003ebaz\u003c/code\u003e with an \u003ccode\u003e=\u003c/code\u003e in our directive, any changes to \u003ccode\u003ebaz\u003c/code\u003e within our directive will be reflected back in the parent. Similarly, any changes to \u003ccode\u003efoo\u003c/code\u003e within the parent will change \u003ccode\u003ebaz\u003c/code\u003e.\u003c/p\u003e\n\n\u003ch2\u003ebaz: \u0026lsquo;@\u0026rsquo;\u003c/h2\u003e\n\n\u003cp\u003eSuppose that we used \u003ccode\u003e@\u003c/code\u003e instead of \u003ccode\u003e=\u003c/code\u003e. The difference here is that instead of two way binding between the parent and the directive, it is now one way binding. A change to \u003ccode\u003efoo\u003c/code\u003e in the parent will propagate to \u003ccode\u003ebaz\u003c/code\u003e in the directive, but the reverse is not true. If you declare your variable binding with \u003ccode\u003e@\u003c/code\u003e, changes made to that variable within your directive will not affect the parent variable.\u003c/p\u003e\n\n\u003cp\u003eSuccinctly, with an \u003ccode\u003e@\u003c/code\u003e binding, a change to \u003ccode\u003efoo\u003c/code\u003e will change \u003ccode\u003ebaz\u003c/code\u003e, but a change to \u003ccode\u003ebaz\u003c/code\u003e will not change \u003ccode\u003efoo\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eWhy would you use \u003ccode\u003e@\u003c/code\u003e? I don\u0026rsquo;t know. I haven\u0026rsquo;t found a reason to use it yet.\u003c/p\u003e\n\n\u003ch2\u003eeggs: \u0026lsquo;\u0026amp;\u0026rsquo;\u003c/h2\u003e\n\n\u003cpre\u003e\u003ccode class=\"ruby\"\u003eNB: I'm going to change the names for this final example\nsince we are no longer binding a variable, but instead\nwe are binding a function.\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eYes, you can pass a function from a parent scope into a directive in the same way you would pass any other variable.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"javascript\"\u003eangular.module('App.controllers').controller('ParentCtrl', function($scope) {\n  $scope.spam = function() {\n    return \u0026quot;spam spam spam spam\u0026quot;;\n  };\n});\n\nangular.module('App.directives').directive('isolateDirective', function() {\n  return {\n    scope: {\n      eggs: '\u0026amp;'\n    },\n    restrict: \u0026quot;E\u0026quot;\n  };\n});\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThe syntax for passing this into the directive is probably different from what you expect, though:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"html\"\u003e\u0026lt;div ng-controller=\u0026quot;ParentCtrl\u0026quot;\u0026gt;\n  \u0026lt;isolate-directive eggs=\u0026quot;spam()\u0026quot;\u0026gt;\u0026lt;/isolate-directive\u0026gt;\n\u0026lt;/div\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThis markup might appear wrong to you. Why would you pass the evaluation of \u003ccode\u003espam()\u003c/code\u003e into the directive? You want the function, not the return value from it!\u003c/p\u003e\n\n\u003cp\u003eWell, it turns out that this IS how you pass in a function. Under the hood, \u003ccode\u003espam\u003c/code\u003e gets wrapped in a closure so that it can keep any variables from the parent in scope (clever, right?). From within your directive you can simply call \u003ccode\u003escope.eggs()\u003c/code\u003e, and it will return \u003ccode\u003e\u0026quot;spam spam spam spam\u0026quot;\u003c/code\u003e, as if it were being evaluated in the parent.\u003c/p\u003e\n\n\u003cp\u003eAt this point you may be wondering, \u0026ldquo;What would happen if instead of passing \u003ccode\u003espam()\u003c/code\u003e into the directive, I just passed \u003ccode\u003espam\u003c/code\u003e??\u0026ldquo;. Change your markup and add the following \u003ccode\u003elink\u003c/code\u003e property to your directive:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"html\"\u003e\u0026lt;div ng-controller=\u0026quot;ParentCtrl\u0026quot;\u0026gt;\n  \u0026lt;isolate-directive eggs=\u0026quot;spam\u0026quot;\u0026gt;\u0026lt;/isolate-directive\u0026gt;\n\u0026lt;/div\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cpre\u003e\u003ccode class=\"javascript\"\u003eangular.module('App.directives').directive('isolateDirective', function() {\n  return {\n    scope: {\n      eggs: '\u0026amp;'\n    },\n    link: function(scope, element, attributes) {\n      debugger;\n    },\n    restrict: \u0026quot;E\u0026quot;\n  };\n});\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThe \u003ccode\u003elink\u003c/code\u003e function is out of scope (har har) for this post, but, briefly: The\n\u003ccode\u003elink\u003c/code\u003e function can be thought of as a mini-controller that also makes it easy\nto do \u003ccode\u003eDOM\u003c/code\u003e manipulation on the directive element (or any of its children).\nThe directive \u003ccode\u003escope\u003c/code\u003e, the \u003ccode\u003eelement\u003c/code\u003e this directive is declared on (\u003ccode\u003e\u0026lt;isolate-directive\u0026gt;\u003c/code\u003e), and any \u003ccode\u003eattributes\u003c/code\u003e declared on the element are available as\narguments to the \u003ccode\u003elink\u003c/code\u003e function.\u003c/p\u003e\n\n\u003cp\u003eCheck it out in a console. You\u0026rsquo;ll see the closure that your function was wrapped in:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e\u0026gt; scope.eggs\n  function (a){return l(e,a)}\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eIt bears mentioning that if you\u0026rsquo;re passing a function down into a directive, you\u0026rsquo;re probably doing something wrong. If you\u0026rsquo;re only using that function within the directive and no where else, you should declare it within the directive\u0026rsquo;s \u003ccode\u003elink\u003c/code\u003e function, not the parent controller. If you\u0026rsquo;re using the function within both the parent controller and the directive, then you should extract that function into a service object that can be injected (similar idea to what I blogged about \u003ca href=\"/why-you-should-avoid-broadcast-and-emit-in-angular\"\u003ehere\u003c/a\u003e).\u003c/p\u003e\n\n\u003ch2\u003eAnd some other bits\u003c/h2\u003e\n\n\u003cp\u003eThere\u0026rsquo;s an additional wrinkle that can be added to directive declaration, which I personally believe is one of the chief reasons people find directives so confusing. Throughout my examples I\u0026rsquo;ve been declaring the variables in the isolate scope with just a bare symbol, \u003ccode\u003e@\u003c/code\u003e, \u003ccode\u003e=\u003c/code\u003e, \u003ccode\u003e\u0026amp;\u003c/code\u003e, e.g. You can actually provide a name to these symbols, which is what will be used as the key in your directive markup.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"javascript\"\u003eangular.module('App.directives').directive('isolateDirective', function() {\n  return {\n    scope: {\n      baz: '=quux'\n    },\n    restrict: \u0026quot;E\u0026quot;\n  };\n});\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cpre\u003e\u003ccode class=\"html\"\u003e\u0026lt;div ng-controller=\u0026quot;ParentCtrl\u0026quot;\u0026gt;\n  \u0026lt;isolate-directive quux=\u0026quot;foo\u0026quot;\u0026gt;\u0026lt;/isolate-directive\u0026gt;\n\u0026lt;/div\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003e\u003ccode\u003efoo\u003c/code\u003e is the same variable from the parent as before, but notice the\ndifference now: \u003ccode\u003equux\u003c/code\u003e is set to \u003ccode\u003efoo\u003c/code\u003e in \u003ccode\u003e\u0026lt;isolate-directive\u0026gt;\u003c/code\u003e. \u003ccode\u003equux\u003c/code\u003e serves\nno purpose other than as the attribute name. Within your isolate scope you\nwill still use \u003ccode\u003escope.baz\u003c/code\u003e to access the value of \u003ccode\u003efoo\u003c/code\u003e from the parent. Why\nwould you want this? Again, I have no idea. I avoid it, and you probably\nshould, too.\u003c/p\u003e\n\n\u003ch2\u003eConclusion\u003c/h2\u003e\n\n\u003cp\u003eIsolate scope really isn\u0026rsquo;t that hard. If you only declare your scope using\n\u003ccode\u003ebaz: '='\u003c/code\u003e (which you should, because it\u0026rsquo;s a lot easier), all you need to\nremember is that \u003ccode\u003ebaz\u003c/code\u003e will be available in your directive scope as whatever\nyou set it to from the parent.\u003c/p\u003e\n","slug":"angularjs-isolate-scope-primer","createdAt":"Apr 4 2014","mtime":1396637583}