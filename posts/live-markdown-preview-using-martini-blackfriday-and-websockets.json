{"title":"Live Markdown Preview using Martini, Blackfriday, and Websockets","body":"\u003cp\u003eI was recently checking out gophercasts.io when I saw the post on \u003ca href=\"https://gophercasts.io/lessons/3-martini-and-markdown\"\u003eMartini and\nMarkdown\u003c/a\u003e. I had\npreviously created a blog using Revel that had live markdown parsing so I could\nwrite my posts and make sure they looked right, so I decided to port it as a\nquick little example to Martini.\u003c/p\u003e\n\n\u003cp\u003eThe repo for all the code in this post can be found \u003ca href=\"https://github.com/stuartnelson3/go-websocket-md-parser\"\u003ehere\u003c/a\u003e.\u003c/p\u003e\n\n\u003ch2\u003eSetup\u003c/h2\u003e\n\n\u003cp\u003eSince we\u0026rsquo;re using Martini, let\u0026rsquo;s set up our project for the defaults it expects.\u003c/p\u003e\n\n\u003cp\u003eCopy the \u003ccode\u003epublic\u003c/code\u003e and \u003ccode\u003etemplates\u003c/code\u003e folders from the repo. They\u0026rsquo;re the html, js,\nand css for this example, and aren\u0026rsquo;t particularly interesting. I will go over\nthe websocket code in \u003ccode\u003escript.js\u003c/code\u003e, but even that is pretty simple.\u003c/p\u003e\n\n\u003ch2\u003eThe Server\u003c/h2\u003e\n\n\u003cp\u003eCreate your \u003ccode\u003eserver.go\u003c/code\u003e file in your main directory. In it, set up your Martini\nserver:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"go\"\u003epackage main\n\nimport (\n    \u0026quot;github.com/codegangsta/martini\u0026quot;\n    \u0026quot;github.com/codegangsta/martini-contrib/render\u0026quot;\n)\n\nfunc main() {\n    m := martini.Classic()\n    m.Use(render.Renderer(render.Options{\n        Layout:     \u0026quot;layout\u0026quot;,\n        Extensions: []string{\u0026quot;.html\u0026quot;}}))\n\n     m.Get(\u0026quot;/\u0026quot;, func(r render.Render) {\n         r.HTML(200, \u0026quot;index\u0026quot;, nil)\n     })\n\n     m.Run()\n}\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eWe use \u003ccode\u003emartini.Classic()\u003c/code\u003e to create our Martini app, then set up some render\noptions. We tell Martini that our layout file is named \u003ccode\u003elayout\u003c/code\u003e, and we declare the\nfiletype extension for our file as html.\u003c/p\u003e\n\n\u003cp\u003eFrom here we set up our \u003ccode\u003e\u0026quot;/\u0026quot;\u003c/code\u003e route using a \u003ccode\u003eGET\u003c/code\u003e request, and tell Martini to\nrender our \u003ccode\u003eindex.html\u003c/code\u003e file with a 200 status. We pass in \u003ccode\u003enil\u003c/code\u003e as the final\nargument because we aren\u0026rsquo;t passing anything into the template for rendering.\u003c/p\u003e\n\n\u003cp\u003eFinally, \u003ccode\u003em.Run()\u003c/code\u003e runs the app.\u003c/p\u003e\n\n\u003cp\u003eAt this point, if you run \u003ccode\u003eserver.go\u003c/code\u003e and navigate to \u003ccode\u003elocalhost:3000\u003c/code\u003e, you\u0026rsquo;ll\nsee a text box where you\u0026rsquo;re supposed to enter your markdown. Since we haven\u0026rsquo;t\nset up the websocket route, though, nothing will happen when you enter text\ninto the textarea.\u003c/p\u003e\n\n\u003ch2\u003eOpening a Websocket, The Client\u003c/h2\u003e\n\n\u003cp\u003eThis is handled in the file you (probably) copied from the repo, in\n\u003ccode\u003epublic/js/script.js\u003c/code\u003e.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"js\"\u003evar host = location.origin.replace(/^http/, 'ws') + '/markdown_preview';\nvar ws = new WebSocket(host);\n\n$(document).on('keyup', 'textarea', function() {\n  var body = $('textarea').val();\n  ws.send(body);\n});\n\nws.onmessage = function(e) {\n  var container = document.querySelector('.post');\n  container.innerHTML = e.data;\n  $('pre code').each(function(i, e) {hljs.highlightBlock(e)});\n};\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eGoing quickly through the file, we see that lines 1 and 2 create the route to\nour soon to be server websocket route.\u003c/p\u003e\n\n\u003cp\u003eFollowing that, we add a \u003ccode\u003ekeyup\u003c/code\u003e event listener to the document for events\ncoming from the \u003ccode\u003etextarea\u003c/code\u003e. On each \u003ccode\u003ekeyup\u003c/code\u003e event, we send the value of the\n\u003ccode\u003etextarea\u003c/code\u003e to the server.\u003c/p\u003e\n\n\u003cp\u003eLastly, we append the response from the server to the div with class \u003ccode\u003epreview\u003c/code\u003e\nwhen we receive a message on our websocket. If there are any code snippets in\nthe post, we loop through them and highlight the syntax with highlight.js.\u003c/p\u003e\n\n\u003ch2\u003eOpening a Websocket, The Server\u003c/h2\u003e\n\n\u003cp\u003eAdd the following two libraries to your import statement in \u003ccode\u003eserver.go\u003c/code\u003e:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e\u0026quot;github.com/gorilla/websocket\u0026quot;\n\u0026quot;net/http\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eNow we have access to \u003ccode\u003enet/http\u003c/code\u003e, which we will use with \u003ccode\u003egorilla/websocket\u003c/code\u003e to\nopen our socket.\u003c/p\u003e\n\n\u003cp\u003eBelow our index route, create your markdown route:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"go\"\u003em.Get(\u0026quot;/markdown_preview\u0026quot;, func(w http.ResponseWriter, r *http.Request) {\n    ws, err := websocket.Upgrade(w, r, nil, 1024, 1024)\n    if _, ok := err.(websocket.HandshakeError); ok {\n        http.Error(w, \u0026quot;Not a websocket handshake\u0026quot;, 400)\n        return\n    } else if err != nil {\n        return\n    }\n\n    for {\n        messageType, message, err := ws.ReadMessage()\n        if err != nil {\n            return\n        }\n        if err := ws.WriteMessage(messageType, message); err != nil {\n            return\n        }\n    }\n})\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eStarting with the first line:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"go\"\u003em.Get(\u0026quot;/markdown_preview\u0026quot;, func(w http.ResponseWriter, r *http.Request) {\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eWe declare a route for \u003ccode\u003eGET\u003c/code\u003e requests to \u003ccode\u003e\u0026quot;/markdown_preview\u0026quot;\u003c/code\u003e, and pass both the\n\u003ccode\u003ehttp.ResponseWriter\u003c/code\u003e and \u003ccode\u003ehttp.Request\u003c/code\u003e into the handler function. You may be\nwondering why we declare this route as a \u003ccode\u003eGET\u003c/code\u003e request, and why we have the\nresponse reader and writer. The answer is in the next line:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"go\"\u003ews, err := websocket.Upgrade(w, r, nil, 1024, 1024)\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThe browser needs to make the initial connection to the server, at which point\nthe server attempts to upgrade to a websocket connection. If something goes\nwrong with the upgrade, the server bails on the request.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"go\"\u003eif _, ok := err.(websocket.HandshakeError); ok {\n    http.Error(w, \u0026quot;Not a websocket handshake\u0026quot;, 400)\n    return\n} else if err != nil {\n    return\n}\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThe \u003ccode\u003efor\u003c/code\u003e loop is where the magic happens. Now that a websocket has\nbeen successfully opened, the server enters an infinite loop waiting on a\nmessage from the client. It is important to note that \u003ccode\u003ews.ReadMessage()\u003c/code\u003e \u003cstrong\u003eblocks\nwaiting for a message\u003c/strong\u003e.\u003c/p\u003e\n\n\u003cp\u003eThe first line of the \u003ccode\u003efor\u003c/code\u003e loop, as mentioned, blocks until a message is\nreceived from the client.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"go\"\u003emessageType, message, err := ws.ReadMessage()\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003e\u003ccode\u003ews.ReadMessage()\u003c/code\u003e returns three values:\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003emessageType\u003c/code\u003e indicates whether the message received is a binary message or a\ntext message.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003emarkdown\u003c/code\u003e is the message received from the client, which in our case is\nmarkdown.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eerr\u003c/code\u003e is an error, if there was one.\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eIf there was no error on our read, we indicate that the return message is of the same\ntype and echo the message back down the socket, breaking out of the for loop if\nthere\u0026rsquo;s an error on write.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"go\"\u003eif err := ws.WriteMessage(messageType, message); err != nil {\n    return\n}\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eIf you run the server now, you\u0026rsquo;ll find the websocket echoes the text you\nentered.\u003c/p\u003e\n\n\u003ch2\u003eParsing your Markdown\u003c/h2\u003e\n\n\u003cp\u003eThe final step is parsing your markdown. For this we\u0026rsquo;ll be using blackfriday.\u003c/p\u003e\n\n\u003cp\u003eAdd blackfriday to your import statement in \u003ccode\u003eserver.go\u003c/code\u003e:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e\u0026quot;github.com/russross/blackfriday\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eNow, let\u0026rsquo;s add a function to parse the markdown.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"go\"\u003efunc ParseMarkdown(markdown []byte) []byte {\n    return blackfriday.MarkdownCommon(markdown)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003ePretty simple. Now, we just need to update the \u003ccode\u003efor\u003c/code\u003e loop in our\n\u003ccode\u003e\u0026quot;/markdown_preview\u0026quot;\u003c/code\u003e route by parsing the message before we write it back out.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"go\"\u003efor {\n    messageType, message, err := ws.ReadMessage()\n    if err != nil {\n        return\n    }\n    message = ParseMarkdown(message)\n    if err := ws.WriteMessage(messageType, message); err != nil {\n       return\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eNow when you run your server, your markdown will be rendered as html! Images and code snippets also work!\u003c/p\u003e\n\n\u003ch2\u003eThe End\u003c/h2\u003e\n\n\u003cp\u003eHope you enjoyed the post and it gave you some ideas on how to integrate websockets into your next Martini app!\u003c/p\u003e\n","slug":"live-markdown-preview-using-martini-blackfriday-and-websockets","createdAt":"Feb 19 2014","mtime":1392840431}