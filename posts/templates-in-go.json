{"title":"Templates in Go","slug":"templates-in-go","createdAt":"Jul 30 2014","body":"\u003cp\u003eI recently refactored by blog from using\n\u003ca href=\"https://github.com/go-martini/martini\"\u003emartini\u003c/a\u003e to\n\u003ca href=\"http://www.gorillatoolkit.org/pkg/pat\"\u003epat\u003c/a\u003e. While making the change I\nrealized that I had never used golang\u0026rsquo;s \u003ccode\u003etext/template\u003c/code\u003e and \u003ccode\u003ehtml/template\u003c/code\u003e\nlibraries. I\u0026rsquo;ve only had good experiences with the other stdlib packages, and\n(unsurprisingly) this was no different. Here is what I learned about templates\nwhile re-writing my blog.\u003c/p\u003e\n\n\u003ch2\u003eDeclaring Templates\u003c/h2\u003e\n\n\u003cp\u003eSince my blog only has three views, all with the same header and footer, I\nparse all my templates when the app is started using \u003ccode\u003etemplate.ParseFiles()\u003c/code\u003e.\nThis returns the first template parsed, which also holds a reference to all the\nother templates.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"go\"\u003et, _  := template.ParseFiles(\n        \u0026quot;./templates/header.tmpl\u0026quot;,\n        \u0026quot;./templates/footer.tmpl\u0026quot;,\n        \u0026quot;./templates/show.tmpl\u0026quot;,\n        \u0026quot;./templates/index.tmpl\u0026quot;,\n        \u0026quot;./templates/new.tmpl\u0026quot;,\n)\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eAnother option would have been to use \u003ccode\u003etemplate.ParseGlob()\u003c/code\u003e:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"go\"\u003et, _ := template.ParseGlob(\u0026quot;./templates/*.tmpl\u0026quot;)\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eAs mentioned above, I used \u003ccode\u003eParseFiles()\u003c/code\u003e over \u003ccode\u003eParseGlob()\u003c/code\u003e for no reason\nother than I have so few templates. I might change this in the future; the\nchange has no affect on working with the templates.\u003c/p\u003e\n\n\u003ch2\u003eUsing Your Templates\u003c/h2\u003e\n\n\u003cp\u003eNow that you have all of these templates wrapped up in your \u003ccode\u003et\u003c/code\u003e variable, how\ndo you use them? The easiest way (in my opinion) is with \u003ccode\u003eExecuteTemplate()\u003c/code\u003e.\nYou pass it an \u003ccode\u003eio.Writer\u003c/code\u003e, a template name (one of the files parsed in \u003ccode\u003et\u003c/code\u003e),\nand an \u003ccode\u003einterface{}\u003c/code\u003e to be rendered into the template:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"go\"\u003emux.Get(\u0026quot;/{slug}\u0026quot;, func(w http.ResponseWriter, r *http.Request) {\n        p, _ := findPost(r.URL.Query().Get(\u0026quot;:slug\u0026quot;))\n        t.ExecuteTemplate(w, \u0026quot;show.tmpl\u0026quot;, p)\n})\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eYou may be saying, \u0026ldquo;Why is it \u003ccode\u003eshow.tmpl\u003c/code\u003e? Why not \u003ccode\u003e./templates/show.tmpl\u003c/code\u003e?\u0026rdquo;\n\u003ccode\u003eParseFiles()\u003c/code\u003e and \u003ccode\u003eParseGlob()\u003c/code\u003e each give names to the templates it parses, the\nfile\u0026rsquo;s \u003cstrong\u003ebasename\u003c/strong\u003e:\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e./templates/show.tmpl\u003c/code\u003e -\u0026gt; \u003ccode\u003eshow.tmpl\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e./templates/index.tmpl\u003c/code\u003e -\u0026gt; \u003ccode\u003eindex.tmpl\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e./templates/new.tmpl\u003c/code\u003e -\u0026gt; \u003ccode\u003enew.tmpl\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003eet c.\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eThat name is how you refer to the template in \u003ccode\u003eExecuteTemplate()\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eThe above code should be copacetic. \u003ccode\u003eshow.tmpl\u003c/code\u003e is rendered with \u003ccode\u003ep\u003c/code\u003e as its\ncontext (explanation to come), and the result is written to \u003ccode\u003ew\u003c/code\u003e.\u003c/p\u003e\n\n\u003ch2\u003eInside the Template\u003c/h2\u003e\n\n\u003cp\u003eThe actual use of an object inside a template is pretty straight forward.\n\u003ccode\u003e{{.}}\u003c/code\u003e is the current context. Since we passed \u003ccode\u003ep\u003c/code\u003e, a Post, into our\n\u003ccode\u003eshow.tmpl\u003c/code\u003e template, \u003ccode\u003e{{.}}\u003c/code\u003e represents that Post struct:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"html\"\u003e\u0026lt;div class=\u0026quot;post mt2\u0026quot;\u0026gt;\n  \u0026lt;div class=\u0026quot;date\u0026quot;\u0026gt;{{.CreatedAt}}\u0026lt;/div\u0026gt;\n  \u0026lt;h1\u0026gt;{{.Title}}\u0026lt;/h1\u0026gt;\n  \u0026lt;div\u0026gt;{{.Body}}\u0026lt;/div\u0026gt;\n\u0026lt;/div\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eEach Post has Title, Body, and CreatedAt fields. They get interpolated into the\ntemplate where we access them: \u003ccode\u003e{{.CreatedAt}}\u003c/code\u003e is \u003ccode\u003ep.CreatedAt\u003c/code\u003e, e.g.\nAddtionally, some basic logic is available, such as \u003ccode\u003e{{if}}...{{end}}\u003c/code\u003e and\n\u003ccode\u003e{{range}}...{{end}}\u003c/code\u003e.  When iterating using \u003ccode\u003e{{range}}\u003c/code\u003e, the context for\n\u003ccode\u003e{{.}}\u003c/code\u003e switches to the current item being iterated over:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"go\"\u003e// The relevant handler.\nmux.Get(\u0026quot;/\u0026quot;, func(w http.ResponseWriter, r *http.Request) {\n        posts := allBlogPosts()\n        t.ExecuteTemplate(w, \u0026quot;index.tmpl\u0026quot;, posts)\n})\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cpre\u003e\u003ccode class=\"html\"\u003e\u0026lt;!-- index.tmpl --\u0026gt;\n\u0026lt;!-- {{.}} is initially a slice of all Posts --\u0026gt;\n\u0026lt;ul class=\u0026quot;posts\u0026quot;\u0026gt;\n  {{range .}}\n  \u0026lt;li\u0026gt;\n    \u0026lt;!-- {{.}} is now a single Post --\u0026gt;\n    \u0026lt;div class=\u0026quot;datestamp\u0026quot;\u0026gt;{{.CreatedAt}}\u0026lt;/div\u0026gt;\n    \u0026lt;div\u0026gt;\u0026lt;a href=\u0026quot;/{{.Slug}}\u0026quot;\u0026gt;{{.Title}}\u0026lt;/a\u0026gt;\u0026lt;/div\u0026gt;\n  \u0026lt;/li\u0026gt;\n  {{end}}\n\u0026lt;/ul\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003ch2\u003eTemplates in Templates\u003c/h2\u003e\n\n\u003cp\u003eFrom the list of templates above, you notice that I have\n\u003ccode\u003e\u0026quot;./templates/header.tmpl\u0026quot;\u003c/code\u003e and \u003ccode\u003e\u0026quot;./templates/footer.tmpl\u0026quot;\u003c/code\u003e. As expected, this\nis the header and footer markup common to all my pages. You can render them in\nother templates like this:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"html\"\u003e\u0026lt;!-- show.tmpl --\u0026gt;\n{{template \u0026quot;header.tmpl\u0026quot;}}\n\u0026lt;div class=\u0026quot;post mt2\u0026quot;\u0026gt;\n  \u0026lt;div class=\u0026quot;date\u0026quot;\u0026gt;{{.CreatedAt}}\u0026lt;/div\u0026gt;\n  \u0026lt;h1\u0026gt;{{.Title}}\u0026lt;/h1\u0026gt;\n  \u0026lt;div\u0026gt;{{.Body}}\u0026lt;/div\u0026gt;\n\u0026lt;/div\u0026gt;\n{{template \u0026quot;footer.tmpl\u0026quot;}}\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThat\u0026rsquo;s all. \u003ccode\u003et\u003c/code\u003e, our template returned from \u003ccode\u003eParseFiles()\u003c/code\u003e, already knows about\n\u003ccode\u003efooter.tmpl\u003c/code\u003e and \u003ccode\u003eheader.tmpl\u003c/code\u003e and quite happily renders them in the other\ntemplates.  They\u0026rsquo;re just static content so this solves my issue. What if you\nneed to interpolate something into them, though? Let\u0026rsquo;s say you want to put\n\u003ccode\u003ep.CreatedAt\u003c/code\u003e in the footer (don\u0026rsquo;t ask me why).\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"html\"\u003e\u0026lt;!-- one of your .tmpl --\u0026gt;\n{{template \u0026quot;footer.tmpl\u0026quot; .CreatedAt}}\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThe final argument to \u003ccode\u003e{{template}}\u003c/code\u003e, after the template name, is set to\n\u003ccode\u003e{{.}}\u003c/code\u003e (the context) in that new template. So in our footer we can display\n\u003ccode\u003ep.CreatedAt\u003c/code\u003e like this:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"html\"\u003e\u0026lt;!-- footer.tmpl --\u0026gt;\n    \u0026lt;/div\u0026gt;\n    \u0026lt;h1\u0026gt;{{.}}\u0026lt;/h1\u0026gt;\n  \u0026lt;/body\u0026gt;\n\u0026lt;/html\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eYou can pass anything into subsequent templates to become the context. You can\nwork with the context in that new template the same as if it were being\nrendered from \u003ccode\u003eExecuteTemplate()\u003c/code\u003e.\u003c/p\u003e\n\n\u003ch2\u003eConclusion\u003c/h2\u003e\n\n\u003cp\u003eTemplates are pretty simple in go. There\u0026rsquo;s a lot of additional functionality\nthat I haven\u0026rsquo;t covered, so if you want to learn more check out the Further\nReading section.\u003c/p\u003e\n\n\u003ch2\u003eFurther Reading\u003c/h2\u003e\n\n\u003cul\u003e\n\u003cli\u003eThe docs for \u003ca href=\"http://golang.org/pkg/text/template/\"\u003etext/template\u003c/a\u003e and\n\u003ca href=\"http://golang.org/pkg/html/template/\"\u003ehtml/template\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"http://golang-examples.tumblr.com/post/87553422434/template-and-associated-templates\"\u003eThis\narticle\u003c/a\u003e\nis awesome. It has a lot of great info that probably makes this post\nunnecessary.\u003c/li\u003e\n\u003cli\u003eA more in-depth \u003ca href=\"http://hugo.spf13.com/templates/go-templates\"\u003eread\u003c/a\u003e on using\nthe templating language.\u003c/li\u003e\n\u003c/ul\u003e\n","mtime":1406742351}