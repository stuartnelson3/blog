{"title":"Github-style Drag-n-Drop Image Uploads","slug":"github-style-drag-n-drop-image-uploads","createdAt":"Aug 27 2014","body":"\u003cp\u003eIt’s a foregone conclusion at this point that you’re using github. One of the\nthings I always found neat about it is how easy it is to add an image to a\npull-request.  Drag! Drop! Boom, image uploaded! I liked the feature, so I\ndecided to figure out how it’s done.\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003en.b.\u003c/strong\u003e Most of the code in this post is regular old javascript. For\nsimplicity’s sake I’ve used jQuery in a couple places.\u003c/p\u003e\n\n\u003ch2\u003eWhat Github does\u003c/h2\u003e\n\n\u003cp\u003eLooking at the network tab when dropping a file, we see four separate requests:\u003c/p\u003e\n\n\u003col\u003e\n\u003cli\u003e\u003ccode\u003ePOST\u003c/code\u003e request to github requesting AWS credentials. These will be used to\nupload your image directly to s3.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eOPTIONS\u003c/code\u003e request to AWS. This checks that the endpoint being hit on s3\naccepts uploads from the referrer (your current location) with the HTTP verb\nyou’re using.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ePOST\u003c/code\u003e request to s3 uploading the image file. The XML response has the\nlocation of the uploaded file.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ePUT\u003c/code\u003e request to github sending the s3 location for the file.\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003eOnce this is all done, the \u003ccode\u003e\u0026lt;textarea\u0026gt;\u003c/code\u003e is updated to have the correct path to\nthe image.\u003c/p\u003e\n\n\u003ch2\u003eWhat we’re going to do\u003c/h2\u003e\n\n\u003cp\u003eWe’re going to focus on going from dragging and dropping an image to uploading it\nand finally updating the \u003ccode\u003e\u0026lt;textarea\u0026gt;\u003c/code\u003e with the image path for this post. This post\nwill not cover how to upload to s3. Instead, it will assume the image is being\nstored on your server.\u003c/p\u003e\n\n\u003ch2\u003eThe drop\u003c/h2\u003e\n\n\u003cp\u003eThe drop is a regular old jQuery handler:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e$(document).on(\u0026#39;drop\u0026#39;, \u0026#39;textarea\u0026#39;, function(e) {\n  // Code to come.\n});\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eWhen a drop event originates from a \u003ccode\u003e\u0026lt;textarea\u0026gt;\u003c/code\u003e and bubbles up to the\n\u003ccode\u003edocument\u003c/code\u003e, execute the callback.\u003c/p\u003e\n\n\u003ch2\u003eImage placeholder text\u003c/h2\u003e\n\n\u003cp\u003eWith our event \u003ccode\u003ee\u003c/code\u003e passed into the callback, we can add some placeholder text\nto the \u003ccode\u003e\u0026lt;textarea\u0026gt;\u003c/code\u003e. I defined a helper function for this, just because I\ndidn’t want to cram more code into the callback:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003efunction addImageMarkdown(element, altText) {\n  var startPos = element.selectionStart;\n  var endPos = element.selectionEnd;\n  element.value = element.value.substring(0, startPos)\n  + \u0026#34;![\u0026#34; + altText + \u0026#34;]()\\r\\n\u0026#34;\n  + element.value.substring(endPos, element.value.length);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThe function \u003ccode\u003eaddImageMarkdown\u003c/code\u003e takes a \u003ccode\u003e\u0026lt;textarea\u0026gt;\u003c/code\u003e element as its first\nargument, and whatever text you want to put in for the alt text on the image as\nits second argument.  Looking at the two variables declared, we find the cursor\nstart and end position. Using these variables, markdown for the image is\ninserted at the cursor position, leaving the text already there intact.\u003c/p\u003e\n\n\u003cp\u003eAs you’ll see below, the \u003ccode\u003ealtText\u003c/code\u003e I use is the name of the dropped file. This\nfilename is also used in a regex to update the image markdown once the\nfile has been uploaded.\u003c/p\u003e\n\n\u003ch2\u003eThe callback pt. 1: The file\u003c/h2\u003e\n\n\u003cp\u003e\u003cstrong\u003en.b.\u003c/strong\u003e All of the following code will be executed within the aforementioned\ncallback.\u003c/p\u003e\n\n\u003cp\u003eFirst things first, we need to prevent the default action:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003ee.preventDefault();\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eWe would be directed to the location for the uploaded image if we didn’t.\u003c/p\u003e\n\n\u003cp\u003eFrom here we need to access the original (native) drop event. The drop event\nhas a \u003ccode\u003edataTransfer\u003c/code\u003e object as an attribute (read more about the \u003ccode\u003edataTransfer\u003c/code\u003e\nobject \u003ca href=\"https://developer.mozilla.org/en-US/docs/Web/API/DataTransfer\"\u003ehere\u003c/a\u003e).\nFrom this object we get a list of the files dropped onto the \u003ccode\u003e\u0026lt;textarea\u0026gt;\u003c/code\u003e.\nWe’re going to loop through this array of files and upload each one to the\nserver:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003evar dt = e.originalEvent.dataTransfer;\nfor (var i = 0; i \u0026lt; dt.files.length; i++) {\n  var f = dt.files[i];\n  // Upload the files.\n}\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003ch2\u003eThe callback pt. 2: The form\u003c/h2\u003e\n\n\u003cp\u003eWe have to upload the image in a multi-part form to the server, so we’ll create\na \u003ccode\u003eFormData\u003c/code\u003e object, and append the file to that:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003efor (var i = 0; i \u0026lt; dt.files.length; i++) {\n  var f = dt.files[i];\n\n  // This is where we add our image markdown to the textarea!\n  var t = e.currentTarget; // This is the textarea.\n  addImageMarkdown(t, f.name);\n\n  var fd = new FormData();\n  fd.append(\u0026#34;file\u0026#34;, f);\n\n  // More to come.\n}\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eAll we’re doing here as accessing the file’s \u003ccode\u003ename\u003c/code\u003e property for our markdown\nand then appending it to the \u003ccode\u003eFormData\u003c/code\u003e object. The \u003ccode\u003eappend\u003c/code\u003e method takes a\nkey/value pair, where the value is either a \u003ccode\u003eFile\u003c/code\u003e, a \u003ccode\u003eBlob\u003c/code\u003e, or a string.\nSince we have a file object, we can append it directly to the form.  You can\nread more about the \u003ccode\u003eFile\u003c/code\u003e object\n\u003ca href=\"https://developer.mozilla.org/en-US/docs/Web/API/File\"\u003ehere\u003c/a\u003e.\u003c/p\u003e\n\n\u003ch2\u003eThe callback pt. 3: The request\u003c/h2\u003e\n\n\u003cp\u003eNow we’re going to make a \u003ccode\u003ePOST\u003c/code\u003e request to our server, set a callback for when\nour file has been successfully uploaded, and send the file.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003evar request = new XMLHttpRequest();\nrequest.open(\u0026#34;POST\u0026#34;, \u0026#34;/upload\u0026#34;);\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eYep, raw \u003ccode\u003eXMLHttpRequest\u003c/code\u003e object. No jQuery here. Set the verb and url. That\nwasn’t so hard.\u003c/p\u003e\n\n\u003cp\u003eThe success callback for the upload will take a little explaining, though:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003efor (var i = 0; i \u0026lt; dt.files.length; i++) {\n  var f = dt.files[i];\n\n  var t = e.currentTarget; // This is the textarea.\n\n  // Code from previous sections.\n\n  request.onloadend = function(filename) {\n    // Form a closure around the filename.\n    return function(e) {\n      var resp = e.currentTarget.response;\n      // Update the text with the correct path for the image.\n      var re = new RegExp(\u0026#34;\\\\[\u0026#34; + filename + \u0026#34;\\\\]\\\\(\\\\)\u0026#34;);\n      t.value = t.value.replace(re, function($1) {\n        return $1.replace(\u0026#34;()\u0026#34;, \u0026#34;(\u0026#34;+resp.slice(1)+\u0026#34;)\u0026#34;);\n      });\n    };\n  }(f.name);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eIgnoring the closure for now, we see that the inner function takes the server’s\nresponse (the path to the newly uploaded file), searches the \u003ccode\u003e\u0026lt;textarea\u0026gt;\u003c/code\u003e for\nthe matching image markdown, and inserts the correct path to the image. There’s\nprobably a better way to do this than a double \u003ccode\u003ereplace\u003c/code\u003e, but I would rather\nuse two simple functions than one complicated one.\u003c/p\u003e\n\n\u003cp\u003eNow, the closure. We wrap the callback function in another function that takes\nour filename as an argument. This outer function is immediately executed,\nbinding the filename to the callback. This seems complicated, but it’s actually\nnecessary. Let’s pretend we use the above callback, but without the closure:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003efor (var i = 0; i \u0026lt; dt.files.length; i++) {\n  var f = dt.files[i];\n\n  request.onloadend = function(e) {\n    var resp = e.currentTarget.response;\n    // Update the text with the correct path for the image.\n\n    // Here we\u0026#39;re using f.name from the outer scope instead of\n    // passing it in as an argument to the closure.\n    var re = new RegExp(\u0026#34;\\\\[\u0026#34; + f.name + \u0026#34;\\\\]\\\\(\\\\)\u0026#34;);\n    t.value = t.value.replace(re, function($1) {\n      return $1.replace(\u0026#34;()\u0026#34;, \u0026#34;(\u0026#34;+resp.slice(1)+\u0026#34;)\u0026#34;);\n    });\n  };\n}\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eSuppose we are uploading multiple image files at once. As we loop through our\nfiles, the value for \u003ccode\u003ef\u003c/code\u003e keeps changing! Our success callback doesn’t know\nthis, though: at the time each success callback is executed, it uses \u003cem\u003ewhatever\nthe current value of \u003ccode\u003ef\u003c/code\u003e is\u003c/em\u003e. In all likelihood, due to the delay in uploading\nthe files, the value of \u003ccode\u003ef\u003c/code\u003e in each success callback is going to be the \u003cstrong\u003esame\n(final) file!\u003c/strong\u003e This means our regex will be wrong, and with an incorrect regex\nthe code won’t update the correct markdown with the image path.\u003c/p\u003e\n\n\u003cp\u003eHow do you solve this? The closure! The closure binds the value of \u003ccode\u003ef.name\u003c/code\u003e\nthat we pass in as an argument so that each success callback has the correct\nfile name.\u003c/p\u003e\n\n\u003cp\u003eFinally, after all that, we send our form object to the server:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003erequest.send(fd);\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eWhew.\u003c/p\u003e\n\n\u003ch2\u003eConclusion\u003c/h2\u003e\n\n\u003cp\u003eThere you have it. Other than the bit of trickery using the closure, it’s a lot\nof simple steps stitched together. I’m currently using this on my blog because\nI’m lazy and don’t want to manually upload files, and it’s pretty awesome. My\nblog set up with the live markdown preview is described\n\u003ca href=\"/live-markdown-preview-using-martini-blackfriday-and-websockets\"\u003ehere\u003c/a\u003e.  It’s\npretty neat to see images appear in my post preview as soon as they are\nfinished uploading.  I’ll do a post soon covering the server side code (written\nin Go) which handles the upload and resizing too-large images.\u003c/p\u003e\n\n\u003cp\u003eThe source used in my blog can be seen \u003ca href=\"https://github.com/stuartnelson3/blog/blob/master/public/js/script.js\"\u003ehere\u003c/a\u003e.\u003c/p\u003e\n","mtime":1409149801}