{"title":"Adding Live Updates to Your Webapp","slug":"adding-live-updates-to-your-webapp","createdAt":"Jul 29 2014","body":"\u003cp\u003eThis is a story with three players: the \u003cstrong\u003eClient\u003c/strong\u003e, the \u003cstrong\u003eServer\u003c/strong\u003e, and the \u003cstrong\u003eEvent Source\u003c/strong\u003e.\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"/public/img/three_circles.png\" alt=\"Client, Server, and Event Source\" /\u003e\n\u003c/p\u003e\n\n\u003cp\u003eThe \u003cstrong\u003eClient\u003c/strong\u003e is played by a browser. It connects to your site, requests\ninformation regarding the Event Source, and then connects to the Event Source.\u003c/p\u003e\n\n\u003cp\u003eThe \u003cstrong\u003eServer\u003c/strong\u003e is played by your language of choice, be it Ruby, Python, Go, or\nanyone else. It contains the information on how to connect to the Event Source,\nand is where your business logic resides.\u003c/p\u003e\n\n\u003cp\u003eThe \u003cstrong\u003eEvent Source\u003c/strong\u003e is played by \u003ca href=\"https://github.com/stuartnelson3/golang-eventsource\"\u003ethis\nrepo\u003c/a\u003e. Written in Go, it accepts\nconnections from Clients, and forwards JSON data received from the Server to\nthem.\u003c/p\u003e\n\n\u003cp\u003eThe three are isolated from each other, and communicate asynchronously.\u003c/p\u003e\n\n\u003ch2\u003eThe Process\u003c/h2\u003e\n\n\u003cp\u003eHere follows the process by which a Client connects to the Server, connects to\nthe Event Source, and receives live updates from the Server by way of the\nEvent Source.\u003c/p\u003e\n\n\u003col\u003e\n\u003cli\u003eThe Client, as previously mentioned, connects to your Server. The Server\nrenders a page for the Client.\u003c/li\u003e\n\u003cli\u003eAsynchronous javascript executes in the browser which requests, from the\nServer, connection info for the Event Source.\u003c/li\u003e\n\u003cli\u003eWith the connection info, the Client connects to the Event Source.\u003c/li\u003e\n\u003cli\u003eWhenever appropriate (a record is updated, e.g.), the Server sends a \u003ccode\u003ePOST\u003c/code\u003e\nrequest to the Event Source. The request contains JSON \u003ccode\u003edata\u003c/code\u003e to be sent to\nClients, and the \u003ccode\u003eeventType\u003c/code\u003e.\u003c/li\u003e\n\u003cli\u003eThe Event Source sends that \u003ccode\u003edata\u003c/code\u003e to all connected Clients.\u003c/li\u003e\n\u003cli\u003eThe Clients execute a callback that handles the \u003ccode\u003edata\u003c/code\u003e.\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003eHere follow explanations of the more interesting parts:\u003c/p\u003e\n\n\u003ch2\u003eThe Client Requests Event Source Connection Info\u003c/h2\u003e\n\n\u003cpre\u003e\u003ccode class=\"javascript\"\u003e$.ajax({\n  url: '/event_stream_info',\n  method: 'GET',\n  success: function(data) {\n    // Connect to Event Source.\n  }\n});\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003ch2\u003eThe Client Connects to the Event Source\u003c/h2\u003e\n\n\u003cp\u003eThe JSON response from the Server looks like this:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"javascript\"\u003e{\n  url: \u0026quot;http://stream-server.com/stream\u0026amp;token=someAuthToken\u0026quot;,\n  eventTypes: [\u0026quot;event1\u0026quot;, \u0026quot;event2\u0026quot;, \u0026quot;event3\u0026quot;]\n}\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eNot mentioned until now, \u003ccode\u003eeventTypes\u003c/code\u003e are identifiers attached to the events\nsent from the Server and fanned out to Clients by the Event Source. Javascript\nhandler functions are set up for different event types.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"javascript\"\u003e$.ajax({\n  url: '/event_stream_info',\n  method: 'GET',\n  success: function(data) {\n    // The new stuff.\n    var source = new EventSource(data.url);\n    source.addEventListener(data.eventTypes[0], function(ev) {\n      var json = JSON.parse(ev.data);\n      // Do something with the json for this event.\n    });\n\n    source.addEventListener(data.eventTypes[1], function(ev) {\n      var json = JSON.parse(ev.data);\n      // Do something with the json for this event.\n    });\n\n    // Et c. Handle the events as necessary.\n  }\n});\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eAs part of the connection made to the Event Source in the \u003ccode\u003esuccess\u003c/code\u003e callback,\nhandlers for specific event types are set up. When receiving events from the\nEvent Source, the Client will only respond to event types for which the Client\nis listening.\u003c/p\u003e\n\n\u003ch2\u003eThe Event Source\u003c/h2\u003e\n\n\u003cp\u003eThis is the interesting part. I\u0026rsquo;ll go through it section by section.\u003c/p\u003e\n\n\u003ch3\u003eImports\u003c/h3\u003e\n\n\u003cp\u003eWe start with the \u003ccode\u003eimport\u003c/code\u003e statement:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"go\"\u003epackage main\n\nimport (\n          \u0026quot;flag\u0026quot;\n          \u0026quot;log\u0026quot;\n          \u0026quot;net/http\u0026quot;\n          \u0026quot;os\u0026quot;\n          \u0026quot;strconv\u0026quot;\n          \u0026quot;time\u0026quot;\n\n          \u0026quot;github.com/antage/eventsource\u0026quot;\n          \u0026quot;github.com/gorilla/handlers\u0026quot;\n          \u0026quot;github.com/gorilla/pat\u0026quot;\n)\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eNothing much interesting to talk about here, just the packages that are used by\nthe Event Source.\u003c/p\u003e\n\n\u003ch3\u003eGlobal Variables\u003c/h3\u003e\n\n\u003cp\u003eContinuing on to the next portion of the Event Source, variables used\nthroughout the code are declared.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"go\"\u003evar (\n        port  = flag.String(\u0026quot;p\u0026quot;, \u0026quot;8080\u0026quot;, \u0026quot;the port to listen on\u0026quot;)\n        token = flag.String(\u0026quot;token\u0026quot;, \u0026quot;token123\u0026quot;, \u0026quot;the app token\u0026quot;)\n        id    = 1\n        es    = eventsource.New(\n                \u0026amp;eventsource.Settings{\n                        Timeout:        5 * time.Second,\n                        CloseOnTimeout: false,\n                        IdleTimeout:    30 * time.Minute,\n                },\n                func(req *http.Request) [][]byte {\n                        return [][]byte{\n                          []byte(\u0026quot;X-Accel-Buffering: no\u0026quot;),\n                          []byte(\u0026quot;Access-Control-Allow-Origin: *\u0026quot;),\n                        }\n                },\n        )\n)\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cul\u003e\n\u003cli\u003eThe first two are command-line flags used to configure the Event Source. The\n\u003ccode\u003ep\u003c/code\u003e is the port, and \u003ccode\u003etoken\u003c/code\u003e is used to authenticate requests.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eid\u003c/code\u003e is the incrementing value used to order events. You can read more about\nits purpose\n\u003ca href=\"http://www.w3.org/TR/2012/WD-eventsource-20120426/#processing-model\"\u003ehere\u003c/a\u003e.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ees\u003c/code\u003e is the \u003ccode\u003eEventSource\u003c/code\u003e. The first argument configures timeout settings,\nand the second argument is a slice of custom headers for the EventSource\nresponse.\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eAll of these are declared as global variables, which is generally a bad idea.\nSince this is such a small \u0026ldquo;app\u0026rdquo; it didn\u0026rsquo;t seem particularly offensive, though.\u003c/p\u003e\n\n\u003ch3\u003emain()\u003c/h3\u003e\n\n\u003cp\u003eCommon practice in Go apps (from what I\u0026rsquo;ve seen) is to declare the \u003ccode\u003emain()\u003c/code\u003e\nfunction at the bottom of the file. I\u0026rsquo;m going to break with that tradition in\nthe hope that it makes the rest of the code easier to understand. So, here is our \u003ccode\u003emain()\u003c/code\u003e:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"go\"\u003efunc main() {\n        flag.Parse()\n\n        defer es.Close()\n\n        m := pat.New()\n        m.Get(\u0026quot;/stream\u0026quot;, tokenHandler(es.ServeHTTP))\n        m.Post(\u0026quot;/update_stream\u0026quot;, tokenHandler(updateStream))\n\n        handler := handlers.LoggingHandler(os.Stdout, m)\n\n        log.Printf(\u0026quot;listening on %s\u0026quot;, *port)\n        log.Fatal(http.ListenAndServe(\u0026quot;:\u0026quot;+*port, handler))\n}\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eStarting off, we parse the command-line flags with \u003ccode\u003eflag.Parse()\u003c/code\u003e, and use\n\u003ccode\u003edefer es.Close()\u003c/code\u003e to make sure that the EventSource is closed when \u003ccode\u003emain()\u003c/code\u003e\nreturns. Next up we create our router using \u003ccode\u003epat.New()\u003c/code\u003e and declare our two\nroutes. Both the routes, \u003ccode\u003e\u0026quot;/stream\u0026quot;\u003c/code\u003e and \u003ccode\u003e\u0026quot;/update_stream\u0026quot;\u003c/code\u003e, pass their\nrespective function handlers into the \u003ccode\u003etokenHandler()\u003c/code\u003e. We\u0026rsquo;ll see below both the\n\u003ccode\u003etokenHandler()\u003c/code\u003e and \u003ccode\u003eupdateStream()\u003c/code\u003e, but not \u003ccode\u003ees.ServeHTTP()\u003c/code\u003e. That is\ndefined\n\u003ca href=\"https://github.com/antage/eventsource/blob/1077d16d7464a3e16dc339a01db15968b05203d6/eventsource.go#L208\"\u003ehere\u003c/a\u003e.\n\u003ccode\u003ees.ServeHTTP()\u003c/code\u003e creates a new consumer of the EventStream, and keeps that\nconnection open (see the Server-Sent-Events spec). Both \u003ccode\u003eupdateStream()\u003c/code\u003e and\n\u003ccode\u003ees.ServeHTTP()\u003c/code\u003e are passed into the \u003ccode\u003etokenHandler()\u003c/code\u003e, which wraps the original\nfunctions in a closure. Explanation soon to come.\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003emain()\u003c/code\u003e ends with some standard house-keeping:\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003ehandlers.LoggingHandler(os.Stdout, m)\u003c/code\u003e logs requests in Apache Common Log\nFormat to \u003ccode\u003estdout\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003elog.Printf(\u0026quot;listening on %s\u0026quot;, *port)\u003c/code\u003e lets you know what port the Event\nSource is listening on\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003elog.Fatal(http.ListenAndServe(\u0026quot;:\u0026quot;+*port, handler))\u003c/code\u003e starts the Event Source\nand logs any error that might have resulted\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch3\u003etokenHandler()\u003c/h3\u003e\n\n\u003cp\u003eNext up is the \u003ccode\u003etokenHandler()\u003c/code\u003e.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"go\"\u003efunc tokenHandler(fn func(w http.ResponseWriter, r *http.Request)) func(http.ResponseWriter, *http.Request) {\n        return func(w http.ResponseWriter, r *http.Request) {\n                w.Header().Set(\u0026quot;Access-Control-Allow-Origin\u0026quot;, \u0026quot;*\u0026quot;)\n                if r.FormValue(\u0026quot;token\u0026quot;) != *token {\n                        http.Error(w, \u0026quot;You are not authorized.\u0026quot;, 403)\n                        return\n                }\n\n                fn(w, r)\n        }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThe \u003ccode\u003etokenHandler()\u003c/code\u003e is a function that accepts as its only argument an\n\u003ccode\u003ehttp.HandlerFunc\u003c/code\u003e, and returns another \u003ccode\u003ehttp.HandlerFunc\u003c/code\u003e that wraps the\noriginal. As mentioned above, this makes use of a closure to first check that\nthe token included in the request (from either the Client or the Server)\nmatches the \u003ccode\u003etoken\u003c/code\u003e set when starting the Event Source. If not, the EventSource\nresponds with a 403. If they match, then the function \u003ccode\u003efn()\u003c/code\u003e passed as an\nargument into \u003ccode\u003etokenHandler()\u003c/code\u003e is executed.\u003c/p\u003e\n\n\u003ch3\u003eupdateStream()\u003c/h3\u003e\n\n\u003cp\u003eLastly, \u003ccode\u003eupdateStream()\u003c/code\u003e.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"go\"\u003efunc updateStream(w http.ResponseWriter, r *http.Request) {\n        es.SendEventMessage(r.FormValue(\u0026quot;data\u0026quot;), r.FormValue(\u0026quot;eventType\u0026quot;), strconv.Itoa(id))\n        id++\n}\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eAnother simple function: take the values for \u003ccode\u003edata\u003c/code\u003e and \u003ccode\u003estream\u003c/code\u003e that were\n\u003ccode\u003ePOST\u003c/code\u003e\u0026rsquo;d from the Server and send them out to all the connected Clients. \u003ccode\u003edata\u003c/code\u003e\nis the JSON data and \u003ccode\u003eeventType\u003c/code\u003e is the eventType that the Clients are\nlistening for. Finally, \u003ccode\u003eid\u003c/code\u003e is incremented.\u003c/p\u003e\n\n\u003ch2\u003eConclusion\u003c/h2\u003e\n\n\u003cp\u003eThere you have it. The whole Event Source is only 65 lines of code, but I think\nit\u0026rsquo;s the simplicity that makes it powerful.\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003eIts only logic is checking for the correct \u003ccode\u003etoken\u003c/code\u003e. There is no complex logic\nto reason about.\u003c/li\u003e\n\u003cli\u003eBecause it doesn\u0026rsquo;t care what data is sent through, the only limits are on\nwhat the Server sends and how the Clients respond to it.\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eConsequently, the Event Source becomes a high-performance conduit that can be\nused to provide live updates to all connected Clients. Additionally, the clearly defined\nboundaries between the Client, Server, and Event Source insulate each piece\nfrom changes in the others, making for a more robust and maintainable system.\u003c/p\u003e\n","mtime":1406685914}